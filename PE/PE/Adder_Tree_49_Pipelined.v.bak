`timescale 1ns / 1ps

module Adder_Tree_49_Pipelined (
    input wire clk,
    input wire rst,
    input wire [16*49-1:0] in_flat_data, // 49 đầu vào nối tiếp (từ MAC)
    output reg [15:0] final_sum
);

    // --- 1. UNPACK INPUT DATA (Tách dây) ---
    wire [15:0] level0 [0:48];
    genvar i;
    generate
        for (i = 0; i < 49; i = i + 1) begin : unpack
            assign level0[i] = in_flat_data[(i*16)+15 : (i*16)];
        end
    endgenerate

    // ====================================================
    // STAGE 1: 49 Inputs -> 24 Adds + 1 Pass -> 25 Regs
    // ====================================================
    wire [15:0] s1_sum [0:23];    // Kết quả cộng tổ hợp
    reg  [15:0] s1_reg [0:24];    // Thanh ghi đường ống (24 tổng + 1 đi thẳng)

    generate
        for (i = 0; i < 24; i = i + 1) begin : st1_adders
            FP_Add_16 u_add1 (.in_numA(level0[2*i]), .in_numB(level0[2*i+1]), .out_data(s1_sum[i]));
        end
    endgenerate

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            for (int k=0; k<25; k=k+1) s1_reg[k] <= 16'd0;
        end else begin
            // Lưu kết quả cộng
            for (int k=0; k<24; k=k+1) s1_reg[k] <= s1_sum[k];
            // Lưu số lẻ (số thứ 49) đi thẳng để đồng bộ thời gian
            s1_reg[24] <= level0[48]; 
        end
    end

    // ====================================================
    // STAGE 2: 25 Inputs -> 12 Adds + 1 Pass -> 13 Regs
    // ====================================================
    wire [15:0] s2_sum [0:11];
    reg  [15:0] s2_reg [0:12];

    generate
        for (i = 0; i < 12; i = i + 1) begin : st2_adders
            FP_Add_16 u_add2 (.in_numA(s1_reg[2*i]), .in_numB(s1_reg[2*i+1]), .out_data(s2_sum[i]));
        end
    endgenerate

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            for (int k=0; k<13; k=k+1) s2_reg[k] <= 16'd0;
        end else begin
            for (int k=0; k<12; k=k+1) s2_reg[k] <= s2_sum[k];
            s2_reg[12] <= s1_reg[24]; // Số lẻ đi thẳng tiếp
        end
    end

    // ====================================================
    // STAGE 3: 13 Inputs -> 6 Adds + 1 Pass -> 7 Regs
    // ====================================================
    wire [15:0] s3_sum [0:5];
    reg  [15:0] s3_reg [0:6];

    generate
        for (i = 0; i < 6; i = i + 1) begin : st3_adders
            FP_Add_16 u_add3 (.in_numA(s2_reg[2*i]), .in_numB(s2_reg[2*i+1]), .out_data(s3_sum[i]));
        end
    endgenerate

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            for (int k=0; k<7; k=k+1) s3_reg[k] <= 16'd0;
        end else begin
            for (int k=0; k<6; k=k+1) s3_reg[k] <= s3_sum[k];
            s3_reg[6] <= s2_reg[12]; // Số lẻ đi thẳng
        end
    end

    // ====================================================
    // STAGE 4: 7 Inputs -> 3 Adds + 1 Pass -> 4 Regs
    // ====================================================
    wire [15:0] s4_sum [0:2];
    reg  [15:0] s4_reg [0:3];

    generate
        for (i = 0; i < 3; i = i + 1) begin : st4_adders
            FP_Add_16 u_add4 (.in_numA(s3_reg[2*i]), .in_numB(s3_reg[2*i+1]), .out_data(s4_sum[i]));
        end
    endgenerate

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            for (int k=0; k<4; k=k+1) s4_reg[k] <= 16'd0;
        end else begin
            for (int k=0; k<3; k=k+1) s4_reg[k] <= s4_sum[k];
            s4_reg[3] <= s3_reg[6]; // Số lẻ đi thẳng
        end
    end

    // ====================================================
    // STAGE 5: 4 Inputs -> 2 Adds -> 2 Regs
    // ====================================================
    wire [15:0] s5_sum [0:1];
    reg  [15:0] s5_reg [0:1];

    generate
        for (i = 0; i < 2; i = i + 1) begin : st5_adders
            FP_Add_16 u_add5 (.in_numA(s4_reg[2*i]), .in_numB(s4_reg[2*i+1]), .out_data(s5_sum[i]));
        end
    endgenerate

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            s5_reg[0] <= 16'd0; s5_reg[1] <= 16'd0;
        end else begin
            s5_reg[0] <= s5_sum[0];
            s5_reg[1] <= s5_sum[1];
        end
    end

    // ====================================================
    // STAGE 6: 2 Inputs -> 1 Add -> Final Output
    // ====================================================
    wire [15:0] final_comb_sum;
    
    FP_Add_16 u_final_add (
        .in_numA(s5_reg[0]), 
        .in_numB(s5_reg[1]), 
        .out_data(final_comb_sum)
    );

    always @(posedge clk or posedge rst) begin
        if (rst) begin
            final_sum <= 16'd0;
        end else begin
            final_sum <= final_comb_sum;
        end
    end

endmodule