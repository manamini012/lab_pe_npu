module wallace_multiplier (
    input  wire clk,
    input  wire rst_n,
    
    // Giao diện điều khiển (Control Interface)
    input  wire valid_in,   // Báo hiệu A, B đang hợp lệ
    output reg  valid_out,  // Báo hiệu P đang hợp lệ
    
    // Dữ liệu
    input  signed [3:0] A,
    input  signed [3:0] B,
    output reg signed [7:0] P
);

    // --- GIAI ĐOẠN 1: TẠO TÍCH RIÊNG (PPG) THEO BAUGH-WOOLEY ---
    // Không cần mở rộng dấu lên 8-bit, chỉ cần ma trận 4x4 gọn nhẹ
    
    wire [3:0] row0, row1, row2, row3;
    
    // Hàng 0: a[3]b[0] bị đảo (do Baugh-Wooley)
    assign row0 = { ~(A[3]&B[0]), A[2]&B[0], A[1]&B[0], A[0]&B[0] };
    
    // Hàng 1: a[3]b[1] bị đảo
    assign row1 = { ~(A[3]&B[1]), A[2]&B[1], A[1]&B[1], A[0]&B[1] };
    
    // Hàng 2: a[3]b[2] bị đảo
    assign row2 = { ~(A[3]&B[2]), A[2]&B[2], A[1]&B[2], A[0]&B[2] };
    
    // Hàng 3 (Hàng dấu của B): Các bit thường bị đảo, bit dấu a[3]b[3] giữ nguyên
    assign row3 = { A[3]&B[3], ~(A[2]&B[3]), ~(A[1]&B[3]), ~(A[0]&B[3]) };

    // --- GIAI ĐOẠN 2: CÂY NÉN WALLACE ---
    
    wire [7:0] sum_st1, carry_st1;
    wire [7:0] sum_st2, carry_st2;
    
    // Chuẩn bị các vector đầu vào cho CSA (Shift đúng trọng số)
    // Baugh-Wooley yêu cầu cộng thêm '1' tại cột 3 (trọng số 2^3) và cột 4 (trọng số 2^4)
    // Ta nhúng hằng số '1' này vào các chỗ trống của ma trận để tiết kiệm bộ cộng.

    wire [7:0] w_row0, w_row1, w_row2, w_row3;
    
    // Sắp xếp ma trận và chèn hằng số '1'
    assign w_row0 = { 4'b0000, row0 }; // Trọng số: 2^3..2^0
    assign w_row1 = { 3'b000, row1, 1'b0 }; // Trọng số: 2^4..2^1
    assign w_row2 = { 2'b00, row2, 2'b00 }; // Trọng số: 2^5..2^2
    assign w_row3 = { 1'b0, row3, 3'b000 }; // Trọng số: 2^6..2^3

    // Hằng số bù '1' của Baugh-Wooley:
    // Cần +1 tại bit 4 (thuộc row1) và +1 tại bit 3 (thuộc row0).
    // Thay vì dùng bộ cộng riêng, ta sửa trực tiếp logic PPG phía trên hoặc
    // đơn giản là thêm một vector hằng số vào cây nén.
    // Ở đây ta dùng vector hằng số (Constant Vector) để code dễ hiểu.
    wire [7:0] w_const = 8'b1011_0000; 
    // Wait! Baugh-Wooley chuẩn cho 4-bit là thêm:
    // - 1 vào cột 3 (Weight 8)
    // - 1 vào cột 7 (Weight 128) -> Bit dấu kết quả.
    // Logic chuẩn xác:
    // Vector bù = 1 tại vị trí 2^3 và 1 tại vị trí 2^7 ?
    // Công thức: -2^7 + 2^4 + 2^3. 
    // Để đơn giản hóa cho bạn, ta dùng logic Wallace nén 4 hàng w_row, 
    // còn việc xử lý số bù sẽ thực hiện ở Final Adder.
    
    // --- NÉN TẦNG 1 ---
    csa #(.WIDTH(8)) stage1 (
        .op1(w_row0), .op2(w_row1), .op3(w_row2),
        .sum(sum_st1), .carry(carry_st1)
    );
    
    // --- NÉN TẦNG 2 ---
    // Nén kết quả Tầng 1 và w_row3
    csa #(.WIDTH(8)) stage2 (
        .op1(sum_st1), 
        .op2({carry_st1[6:0], 1'b0}), 
        .op3(w_row3),
        .sum(sum_st2), 
        .carry(carry_st2)
    );

    // --- PIPELINE REGISTERS ---
    reg [7:0] pipe_sum, pipe_carry;
    reg       pipe_valid; // Pipeline cho tín hiệu valid

    always @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            pipe_sum   <= 0;
            pipe_carry <= 0;
            pipe_valid <= 0;
            P          <= 0;
            valid_out  <= 0;
        end else begin
            // Lưu kết quả nén vào Pipeline
            pipe_sum   <= sum_st2;
            pipe_carry <= carry_st2;
            pipe_valid <= valid_in; // Truyền tín hiệu valid theo pipeline

            // --- FINAL ADDER (Giai đoạn cuối) ---
            // Ở đây ta cộng thêm hằng số điều chỉnh Baugh-Wooley
            // Hằng số bù cho 4-bit: 
            // 1. Thêm '1' vào trọng số 2^4 (bit 4)
            // 2. Thêm '1' vào trọng số 2^3 (bit 3) -> Đã được xử lý nếu gộp logic
            // Cách đơn giản nhất: Logic PPG đã đảo bit, giờ ta chỉ cần cộng thêm:
            // Constant = 1 tại bit 4 và 1 tại bit 7 (cho dấu)
            // Vector bù cụ thể: 8'b10010000 (Tại bit 7 và bit 4)
            
            if (pipe_valid) begin
                // Sum + Carry + Constant Correction
                P <= pipe_sum + {pipe_carry[6:0], 1'b0} + 8'b10010000; 
                valid_out <= 1'b1;
            end else begin
                valid_out <= 1'b0; // Không có dữ liệu thì tắt valid
            end
        end
    end

endmodule